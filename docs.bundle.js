"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunklogobot_v3"] = self["webpackChunklogobot_v3"] || []).push([["docs"],{

/***/ "./src/core/error.ts":
/*!***************************!*\
  !*** ./src/core/error.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LogoError = void 0;\nclass LogoError extends Error {\n    constructor(message, location) {\n        super(message);\n        this.name = 'LogoError';\n        this.line = location.line;\n        this.column = location.column;\n        // This is necessary for proper error inheritance in TypeScript\n        Object.setPrototypeOf(this, LogoError.prototype);\n    }\n    toString() {\n        return `${this.name} at line ${this.line}, column ${this.column}: ${this.message}`;\n    }\n}\nexports.LogoError = LogoError;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/error.ts?");

/***/ }),

/***/ "./src/core/index.ts":
/*!***************************!*\
  !*** ./src/core/index.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runLogo = void 0;\nvar logo_runner_1 = __webpack_require__(/*! ./logo-runner */ \"./src/core/logo-runner.ts\");\nObject.defineProperty(exports, \"runLogo\", ({ enumerable: true, get: function () { return logo_runner_1.runLogo; } }));\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/index.ts?");

/***/ }),

/***/ "./src/core/interpreter/interpreter.ts":
/*!*********************************************!*\
  !*** ./src/core/interpreter/interpreter.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Interpreter = void 0;\nclass Interpreter {\n    constructor() {\n        this.variables = new Map();\n    }\n    evaluateExpression(expr) {\n        switch (expr.type) {\n            case 'number':\n                return expr.value;\n            case 'variable': {\n                const value = this.variables.get(expr.value);\n                if (value === undefined) {\n                    throw new Error(`Undefined variable: ${expr.value}`);\n                }\n                return value;\n            }\n            case 'binary': {\n                const left = this.evaluateExpression(expr.left);\n                const right = this.evaluateExpression(expr.right);\n                switch (expr.operator) {\n                    case '+': return left + right;\n                    case '-': return left - right;\n                    case '*': return left * right;\n                    case '/': return left / right;\n                    default: throw new Error(`Unknown operator: ${expr.operator}`);\n                }\n            }\n            case 'comparison': {\n                const left = this.evaluateExpression(expr.left);\n                const right = this.evaluateExpression(expr.right);\n                switch (expr.operator) {\n                    case '<': return left < right;\n                    case '>': return left > right;\n                    case '<=': return left <= right;\n                    case '>=': return left >= right;\n                    case '==': return left === right;\n                    case '!=': return left !== right;\n                    default: throw new Error(`Unknown comparison operator: ${expr.operator}`);\n                }\n            }\n            case 'logical': {\n                const left = this.evaluateExpression(expr.left);\n                // Short-circuit evaluation\n                if (expr.operator === 'and' && !left)\n                    return false;\n                if (expr.operator === 'or' && left)\n                    return true;\n                const right = this.evaluateExpression(expr.right);\n                switch (expr.operator) {\n                    case 'and': return left && right;\n                    case 'or': return left || right;\n                    default: throw new Error(`Unknown logical operator: ${expr.operator}`);\n                }\n            }\n            default:\n                throw new Error(`Unknown expression type: ${expr.type}`);\n        }\n    }\n    evaluateRange(range) {\n        const start = Math.floor(this.evaluateExpression(range.start));\n        const end = Math.floor(this.evaluateExpression(range.end));\n        return { start, end };\n    }\n    interpret(command) {\n        switch (command.type) {\n            case 'forward':\n                return [{\n                        type: 'move',\n                        value: this.evaluateExpression(command.distance)\n                    }];\n            case 'backward':\n                return [{\n                        type: 'move',\n                        value: -this.evaluateExpression(command.distance)\n                    }];\n            case 'turn':\n                return [{\n                        type: 'turn',\n                        value: this.evaluateExpression(command.angle)\n                    }];\n            case 'leftTurn':\n                return [{\n                        type: 'turn',\n                        value: -this.evaluateExpression(command.angle)\n                    }];\n            case 'setPenColor':\n                return [{ type: 'setPenColor', value: command.color }];\n            case 'setPenThickness':\n                return [{\n                        type: 'setPenThickness',\n                        value: this.evaluateExpression(command.thickness)\n                    }];\n            case 'setPenOpacity':\n                return [{\n                        type: 'setPenOpacity',\n                        value: this.evaluateExpression(command.opacity)\n                    }];\n            case 'setPenStyle':\n                return [{ type: 'setPenStyle', value: command.style }];\n            case 'setPenCap':\n                return [{ type: 'setPenCap', value: command.cap }];\n            case 'penUp':\n                return [{ type: 'penUp' }];\n            case 'penDown':\n                return [{ type: 'penDown' }];\n            case 'repeat': {\n                const count = Math.floor(this.evaluateExpression(command.count));\n                const results = [];\n                for (let i = 0; i < count; i++) {\n                    for (const cmd of command.body) {\n                        results.push(...this.interpret(cmd));\n                    }\n                }\n                return results;\n            }\n            case 'while': {\n                const results = [];\n                let iterationCount = 0;\n                const MAX_ITERATIONS = 100;\n                while (this.evaluateExpression(command.condition)) {\n                    if (iterationCount++ > MAX_ITERATIONS) {\n                        throw new Error('Maximum while loop iterations exceeded');\n                    }\n                    for (const cmd of command.body) {\n                        results.push(...this.interpret(cmd));\n                    }\n                }\n                return results;\n            }\n            case 'if': {\n                const results = [];\n                if (this.evaluateExpression(command.mainBranch.condition)) {\n                    for (const cmd of command.mainBranch.body) {\n                        results.push(...this.interpret(cmd));\n                    }\n                }\n                else {\n                    let executed = false;\n                    for (const elifBranch of command.elifBranches) {\n                        if (this.evaluateExpression(elifBranch.condition)) {\n                            for (const cmd of elifBranch.body) {\n                                results.push(...this.interpret(cmd));\n                            }\n                            executed = true;\n                            break;\n                        }\n                    }\n                    if (!executed && command.elseBranch) {\n                        for (const cmd of command.elseBranch) {\n                            results.push(...this.interpret(cmd));\n                        }\n                    }\n                }\n                return results;\n            }\n            case 'for': {\n                const range = this.evaluateRange(command.range);\n                const results = [];\n                // Store original value of loop variable if it exists\n                const originalValue = this.variables.get(command.variable);\n                // Execute loop\n                for (let i = range.start; i <= range.end; i++) {\n                    // Set loop variable\n                    this.variables.set(command.variable, i);\n                    // Execute body\n                    for (const cmd of command.body) {\n                        results.push(...this.interpret(cmd));\n                    }\n                }\n                // Restore original value or delete if it didn't exist\n                if (originalValue !== undefined) {\n                    this.variables.set(command.variable, originalValue);\n                }\n                else {\n                    this.variables.delete(command.variable);\n                }\n                return results;\n            }\n            case 'assignment': {\n                const value = this.evaluateExpression(command.value);\n                this.variables.set(command.name, value);\n                return [];\n            }\n            default:\n                return [];\n        }\n    }\n}\nexports.Interpreter = Interpreter;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/interpreter/interpreter.ts?");

/***/ }),

/***/ "./src/core/lexer/lexer.ts":
/*!*********************************!*\
  !*** ./src/core/lexer/lexer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Lexer = void 0;\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/core/error.ts\");\nclass Lexer {\n    constructor(source) {\n        this.source = source;\n        this.current = 0;\n        this.start = 0;\n        this.line = 1;\n        this.column = 1;\n        this.tokens = [];\n        // Add new keywords\n        this.keywords = {\n            'fw': 'identifier',\n            'bw': 'identifier',\n            'rt': 'identifier',\n            'lt': 'identifier',\n            'pen': 'identifier',\n            'repeat': 'repeat',\n            'while': 'while',\n            'if': 'if',\n            'elif': 'elif',\n            'else': 'else',\n            'for': 'for',\n            'in': 'in',\n            'and': 'and',\n            'or': 'or',\n            'end': 'end'\n        };\n    }\n    tokenize() {\n        while (!this.isAtEnd()) {\n            this.start = this.current;\n            this.scanToken();\n        }\n        this.tokens.push({\n            type: 'eof',\n            lexeme: '',\n            line: this.line,\n            column: this.column\n        });\n        console.log('All tokens:', JSON.stringify(this.tokens, null, 2));\n        return this.tokens;\n    }\n    scanToken() {\n        const char = this.advance();\n        switch (char) {\n            // Existing single-character tokens\n            case '(':\n                this.addToken('leftParen');\n                break;\n            case ')':\n                this.addToken('rightParen');\n                break;\n            case '.':\n                this.addToken('dot');\n                break;\n            case '+':\n                this.addToken('plus');\n                break;\n            case '-':\n                this.addToken('minus');\n                break;\n            case '*':\n                this.addToken('multiply');\n                break;\n            case '/':\n                this.addToken('divide');\n                break;\n            case ':':\n                this.addToken('colon');\n                break;\n            case '[':\n                this.addToken('leftBracket');\n                break;\n            case ']':\n                this.addToken('rightBracket');\n                break;\n            case '\\n':\n                this.addToken('newline');\n                this.line++;\n                this.column = 1;\n                break;\n            // Two-character comparison operators\n            case '=':\n                if (this.match('=')) {\n                    this.addToken('equal'); // == for comparison\n                }\n                else {\n                    this.addToken('equal'); // = for assignment\n                }\n                break;\n            case '!':\n                if (this.match('=')) {\n                    this.addToken('notEqual');\n                }\n                else {\n                    throw new error_1.LogoError(`Unexpected character: '${char}'`, { line: this.line, column: this.column });\n                }\n                break;\n            case '<':\n                this.addToken(this.match('=') ? 'lessEqual' : 'lessThan');\n                break;\n            case '>':\n                this.addToken(this.match('=') ? 'greaterEqual' : 'greaterThan');\n                break;\n            // Whitespace\n            case ' ':\n            case '\\r':\n            case '\\t':\n                this.column++;\n                break;\n            // String literals\n            case '\"':\n                this.string('\"');\n                break;\n            case \"'\":\n                this.string(\"'\");\n                break;\n            // Add this case\n            case '#':\n                // Skip the rest of the line\n                while (this.peek() !== '\\n' && !this.isAtEnd()) {\n                    this.advance();\n                }\n                // Don't add comment tokens to avoid executing them\n                break;\n            default:\n                if (this.isDigit(char)) {\n                    this.number();\n                }\n                else if (this.isAlpha(char)) {\n                    this.identifier();\n                }\n                else {\n                    throw new error_1.LogoError(`Unexpected character: '${char}'`, { line: this.line, column: this.column });\n                }\n                break;\n        }\n    }\n    identifier() {\n        while (this.isAlphaNumeric(this.peek())) {\n            this.advance();\n        }\n        const text = this.source.substring(this.start, this.current);\n        const type = this.keywords[text] || 'identifier';\n        console.log('Found identifier:', text, 'type:', type);\n        this.addToken(type);\n    }\n    string(quote) {\n        while (this.peek() !== quote && !this.isAtEnd()) {\n            if (this.peek() === '\\n')\n                this.line++;\n            this.advance();\n        }\n        if (this.isAtEnd()) {\n            throw new Error('Unterminated string');\n        }\n        this.advance(); // The closing quote\n        // Get the string value without the quotes\n        const value = this.source.substring(this.start + 1, this.current - 1);\n        this.addToken('string', value);\n    }\n    number() {\n        while (this.isDigit(this.peek()))\n            this.advance();\n        // Look for decimal part\n        if (this.peek() === '.' && this.isDigit(this.peekNext())) {\n            this.advance(); // Consume the .\n            while (this.isDigit(this.peek()))\n                this.advance();\n        }\n        const value = parseFloat(this.source.substring(this.start, this.current));\n        this.addToken('number', value);\n    }\n    isAtEnd() {\n        return this.current >= this.source.length;\n    }\n    advance() {\n        this.column++;\n        return this.source[this.current++];\n    }\n    peek() {\n        if (this.isAtEnd())\n            return '\\0';\n        return this.source[this.current];\n    }\n    peekNext() {\n        if (this.current + 1 >= this.source.length)\n            return '\\0';\n        return this.source[this.current + 1];\n    }\n    isDigit(char) {\n        return char >= '0' && char <= '9';\n    }\n    isAlpha(char) {\n        return (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z') ||\n            char === '_';\n    }\n    isAlphaNumeric(char) {\n        return this.isAlpha(char) || this.isDigit(char);\n    }\n    addToken(type, literal) {\n        const text = this.source.substring(this.start, this.current);\n        this.tokens.push({\n            type,\n            lexeme: text,\n            literal: literal !== undefined ? literal : text,\n            line: this.line,\n            column: this.column\n        });\n        this.column += this.current - this.start;\n    }\n    makeToken(type, lexeme = '', literal) {\n        return {\n            type,\n            lexeme,\n            literal,\n            line: this.line,\n            column: this.column\n        };\n    }\n    match(expected) {\n        if (this.isAtEnd())\n            return false;\n        if (this.source[this.current] !== expected)\n            return false;\n        this.current++;\n        this.column++;\n        return true;\n    }\n}\nexports.Lexer = Lexer;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/lexer/lexer.ts?");

/***/ }),

/***/ "./src/core/logo-runner.ts":
/*!*********************************!*\
  !*** ./src/core/logo-runner.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runLogo = void 0;\nconst lexer_1 = __webpack_require__(/*! ./lexer/lexer */ \"./src/core/lexer/lexer.ts\");\nconst parser_1 = __webpack_require__(/*! ./parser/parser */ \"./src/core/parser/parser.ts\");\nconst interpreter_1 = __webpack_require__(/*! ./interpreter/interpreter */ \"./src/core/interpreter/interpreter.ts\");\nfunction runLogo(source) {\n    const lexer = new lexer_1.Lexer(source);\n    const tokens = lexer.tokenize();\n    // Debug logging\n    console.log('Tokens:', tokens);\n    const parser = new parser_1.Parser(tokens);\n    const ast = parser.parse();\n    // Debug logging\n    console.log('AST:', JSON.stringify(ast, null, 2));\n    const interpreter = new interpreter_1.Interpreter();\n    const results = [];\n    // Interpret each command in the AST\n    for (const command of ast) {\n        results.push(...interpreter.interpret(command));\n    }\n    return results;\n}\nexports.runLogo = runLogo;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/logo-runner.ts?");

/***/ }),

/***/ "./src/core/parser/parser.ts":
/*!***********************************!*\
  !*** ./src/core/parser/parser.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nconst error_1 = __webpack_require__(/*! ../error */ \"./src/core/error.ts\");\nclass Parser {\n    constructor(tokens) {\n        this.tokens = tokens;\n        this.current = 0;\n    }\n    parse() {\n        const commands = [];\n        while (!this.isAtEnd()) {\n            this.skipNewlines();\n            if (this.isAtEnd())\n                break;\n            try {\n                const command = this.parseCommand();\n                commands.push(command);\n            }\n            catch (e) {\n                console.error('Error while parsing:', e);\n                console.log('Current token:', this.peek());\n                console.log('Previous token:', this.previous());\n                throw e;\n            }\n        }\n        return commands;\n    }\n    parseCommand() {\n        this.skipNewlines();\n        const token = this.peek();\n        console.log('Parsing command, token:', token);\n        if (token.type === 'for') {\n            console.log('Found for loop');\n            this.advance();\n            return this.parseFor();\n        }\n        if (token.type === 'identifier') {\n            this.advance();\n            if (this.check('equal')) {\n                const name = token.lexeme;\n                if (this.isKeyword(name)) {\n                    throw new error_1.LogoError(`Cannot use keyword '${name}' as a variable name`, { line: token.line, column: token.column });\n                }\n                this.advance(); // consume the '='\n                const value = this.parseExpression();\n                return {\n                    type: 'assignment',\n                    name,\n                    value\n                };\n            }\n            switch (token.lexeme) {\n                case 'fw': return this.parseForward();\n                case 'bw': return this.parseBackward();\n                case 'rt': return this.parseTurn();\n                case 'lt': return this.parseLeftTurn();\n                case 'pen': return this.parsePenCommand();\n                default:\n                    throw new Error('Unknown command');\n            }\n        }\n        else if (token.type === 'repeat') {\n            this.advance();\n            return this.parseRepeat();\n        }\n        else if (token.type === 'while') {\n            this.advance();\n            return this.parseWhile();\n        }\n        else if (token.type === 'if') {\n            this.advance();\n            return this.parseIf();\n        }\n        else if (token.type === 'end' || token.type === 'elif' || token.type === 'else') {\n            // These tokens should be handled by their respective block parsers\n            throw new Error(`Unexpected ${token.type} token outside of a block`);\n        }\n        throw new Error(`Expected command, got ${token.type} (${token.lexeme})`);\n    }\n    skipNewlines() {\n        while (this.check('newline')) {\n            this.advance();\n        }\n    }\n    parsePenCommand() {\n        if (!this.check('dot')) {\n            throw new Error(\"Expected '.' after 'pen'\");\n        }\n        this.advance();\n        const prop = this.consume('identifier', 'Expected property name');\n        if (prop.lexeme === 'up') {\n            this.consume('leftParen', \"Expected '('\");\n            this.consume('rightParen', \"Expected ')'\");\n            return { type: 'penUp' };\n        }\n        if (prop.lexeme === 'down') {\n            this.consume('leftParen', \"Expected '('\");\n            this.consume('rightParen', \"Expected ')'\");\n            return { type: 'penDown' };\n        }\n        this.consume('equal', \"Expected '='\");\n        switch (prop.lexeme) {\n            case 'color': {\n                const color = this.consume('string', 'Expected color string');\n                return { type: 'setPenColor', color: color.literal };\n            }\n            case 'thickness': {\n                const thickness = this.parseExpression();\n                return { type: 'setPenThickness', thickness };\n            }\n            case 'opacity': {\n                const opacity = this.parseExpression();\n                if (this.previous().type === 'number') {\n                    const value = this.previous().literal;\n                    if (value < 0 || value > 1) {\n                        throw new error_1.LogoError('Opacity must be between 0 and 1', {\n                            line: this.previous().line,\n                            column: this.previous().column\n                        });\n                    }\n                }\n                return { type: 'setPenOpacity', opacity };\n            }\n            case 'style': {\n                const style = this.consume('string', 'Expected style string');\n                if (!['line', 'dash', 'dot'].includes(style.literal)) {\n                    throw new Error('Invalid pen style');\n                }\n                return { type: 'setPenStyle', style: style.literal };\n            }\n            case 'cap': {\n                const cap = this.consume('string', 'Expected cap string');\n                if (!['round', 'butt', 'square'].includes(cap.literal)) {\n                    throw new Error('Invalid pen cap style');\n                }\n                return { type: 'setPenCap', cap: cap.literal };\n            }\n            default:\n                throw new Error('Unknown pen property');\n        }\n    }\n    parseForward() {\n        this.consume('leftParen', \"Expected '(' after fw\");\n        const distance = this.parseExpression();\n        this.consume('rightParen', \"Expected ')'\");\n        return {\n            type: 'forward',\n            distance: distance\n        };\n    }\n    parseBackward() {\n        this.consume('leftParen', \"Expected '(' after bw\");\n        const distance = this.parseExpression();\n        this.consume('rightParen', \"Expected ')'\");\n        return {\n            type: 'backward',\n            distance: distance\n        };\n    }\n    parseTurn() {\n        this.consume('leftParen', \"Expected '(' after rt\");\n        const angle = this.parseExpression();\n        this.consume('rightParen', \"Expected ')'\");\n        return {\n            type: 'turn',\n            angle: angle\n        };\n    }\n    parseLeftTurn() {\n        this.consume('leftParen', \"Expected '(' after lt\");\n        const angle = this.parseExpression();\n        this.consume('rightParen', \"Expected ')'\");\n        return {\n            type: 'leftTurn',\n            angle: angle\n        };\n    }\n    parseRepeat() {\n        const count = this.parseExpression();\n        this.consume('colon', \"Expected ':' after repeat count\");\n        this.skipNewlines();\n        const body = [];\n        while (!this.check('end') && !this.isAtEnd()) {\n            this.skipNewlines();\n            if (!this.check('end')) {\n                body.push(this.parseCommand());\n            }\n        }\n        this.consume('end', \"Expected 'end' after repeat block\");\n        return { type: 'repeat', count, body };\n    }\n    parseWhile() {\n        const condition = this.parseExpression();\n        this.consume('colon', \"Expected ':' after while condition\");\n        this.skipNewlines();\n        const body = [];\n        while (!this.check('end') && !this.isAtEnd()) {\n            this.skipNewlines();\n            if (!this.check('end')) {\n                body.push(this.parseCommand());\n            }\n        }\n        this.consume('end', \"Expected 'end' after while block\");\n        return { type: 'while', condition, body };\n    }\n    parseExpression() {\n        let expr = this.parseLogicalOr();\n        if (this.match('notEqual', 'equal', 'lessThan', 'greaterThan', 'lessEqual', 'greaterEqual')) {\n            const operator = this.operatorFromToken(this.previous().type);\n            const right = this.parseLogicalOr();\n            expr = {\n                type: 'comparison',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseLogicalOr() {\n        let expr = this.parseLogicalAnd();\n        while (this.match('or')) {\n            const operator = 'or';\n            const right = this.parseLogicalAnd();\n            expr = {\n                type: 'logical',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseLogicalAnd() {\n        let expr = this.parseComparison();\n        while (this.match('and')) {\n            const operator = 'and';\n            const right = this.parseComparison();\n            expr = {\n                type: 'logical',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseComparison() {\n        let expr = this.parseAdditive();\n        while (this.match('notEqual', 'equal', 'lessThan', 'greaterThan', 'lessEqual', 'greaterEqual')) {\n            const operator = this.operatorFromToken(this.previous().type);\n            const right = this.parseAdditive();\n            expr = {\n                type: 'comparison',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseAdditive() {\n        let expr = this.parseMultiplicative();\n        while (this.match('plus', 'minus')) {\n            const operator = this.previous().type === 'plus' ? '+' : '-';\n            const right = this.parseMultiplicative();\n            expr = {\n                type: 'binary',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parseMultiplicative() {\n        let expr = this.parsePrimary();\n        while (this.match('multiply', 'divide')) {\n            const operator = this.previous().type === 'multiply' ? '*' : '/';\n            const right = this.parsePrimary();\n            expr = {\n                type: 'binary',\n                operator,\n                left: expr,\n                right\n            };\n        }\n        return expr;\n    }\n    parsePrimary() {\n        if (this.match('number')) {\n            return {\n                type: 'number',\n                value: this.previous().literal\n            };\n        }\n        if (this.match('identifier')) {\n            return {\n                type: 'variable',\n                value: this.previous().lexeme\n            };\n        }\n        if (this.match('leftParen')) {\n            const expr = this.parseExpression();\n            this.consume('rightParen', \"Expected ')' after expression\");\n            return expr;\n        }\n        throw new error_1.LogoError('Expected expression', {\n            line: this.peek().line,\n            column: this.peek().column\n        });\n    }\n    operatorFromToken(type) {\n        switch (type) {\n            case 'notEqual': return '!=';\n            case 'equal': return '==';\n            case 'lessThan': return '<';\n            case 'greaterThan': return '>';\n            case 'lessEqual': return '<=';\n            case 'greaterEqual': return '>=';\n            default: return type;\n        }\n    }\n    consume(type, message) {\n        if (this.check(type)) {\n            return this.advance();\n        }\n        throw new Error(message);\n    }\n    check(type) {\n        if (this.isAtEnd())\n            return false;\n        return this.peek().type === type;\n    }\n    advance() {\n        if (!this.isAtEnd())\n            this.current++;\n        return this.previous();\n    }\n    isAtEnd() {\n        return this.current >= this.tokens.length || this.peek().type === 'eof';\n    }\n    peek() {\n        return this.tokens[this.current];\n    }\n    previous() {\n        return this.tokens[this.current - 1];\n    }\n    match(...types) {\n        for (const type of types) {\n            if (this.check(type)) {\n                this.advance();\n                return true;\n            }\n        }\n        return false;\n    }\n    parseIf() {\n        const mainBranch = this.parseConditionalBranch();\n        const elifBranches = [];\n        let elseBranch = undefined;\n        while (this.match('elif')) {\n            elifBranches.push(this.parseConditionalBranch());\n        }\n        if (this.match('else')) {\n            this.consume('colon', \"Expected ':' after else\");\n            this.skipNewlines();\n            elseBranch = this.parseBlock();\n        }\n        this.consume('end', \"Expected 'end' after if block\");\n        return { type: 'if', mainBranch, elifBranches, elseBranch };\n    }\n    parseConditionalBranch() {\n        const condition = this.parseExpression();\n        console.log('After parsing expression, current token:', this.peek()); // Updated debug\n        this.consume('colon', \"Expected ':' after condition\");\n        this.skipNewlines();\n        const body = this.parseBlock();\n        return { condition, body };\n    }\n    parseBlock() {\n        const commands = [];\n        while (!this.check('end') && !this.check('elif') && !this.check('else') && !this.isAtEnd()) {\n            if (this.check('newline')) {\n                this.advance(); // Skip newlines between commands\n                continue;\n            }\n            commands.push(this.parseCommand());\n        }\n        return commands;\n    }\n    parseFor() {\n        console.log('Parsing for loop, current token:', this.peek());\n        const variable = this.consume('identifier', \"Expected loop variable\").lexeme;\n        console.log('Got variable:', variable);\n        this.consume('in', \"Expected 'in' after loop variable\");\n        this.consume('leftBracket', \"Expected '[' to start range\");\n        const start = this.parseExpression();\n        this.consume('colon', \"Expected ':' in range\");\n        const end = this.parseExpression();\n        this.consume('rightBracket', \"Expected ']' to end range\");\n        this.consume('colon', \"Expected ':' after range\");\n        this.skipNewlines();\n        const body = this.parseBlock();\n        this.consume('end', \"Expected 'end' after for block\");\n        return {\n            type: 'for',\n            variable,\n            range: { type: 'range', start, end },\n            body\n        };\n    }\n    isKeyword(name) {\n        return [\n            'for', 'in', 'end', 'if', 'else', 'elif',\n            'while', 'repeat', 'and', 'or'\n        ].includes(name);\n    }\n}\nexports.Parser = Parser;\n\n\n//# sourceURL=webpack://logobot-v3/./src/core/parser/parser.ts?");

/***/ }),

/***/ "./src/docs.ts":
/*!*********************!*\
  !*** ./src/docs.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst renderer_1 = __webpack_require__(/*! ./renderer */ \"./src/renderer.ts\");\nconst core_1 = __webpack_require__(/*! ./core */ \"./src/core/index.ts\");\nconst documentation = [\n    {\n        title: \"Basic Movement\",\n        examples: [\n            {\n                title: \"Move Forward\",\n                description: \"Moves the turtle forward by specified steps\",\n                code: \"fw(40)\"\n            },\n            {\n                title: \"Move Backward\",\n                description: \"Moves the turtle backward by specified steps\",\n                code: \"bw(30)\"\n            },\n            {\n                title: \"Turn Right\",\n                description: \"Rotates the turtle clockwise by specified degrees\",\n                code: \"rt(90)\\nfw(30)\"\n            },\n            {\n                title: \"Turn Left\",\n                description: \"Rotates the turtle counter-clockwise by specified degrees\",\n                code: \"lt(90)\\nfw(30)\"\n            }\n        ]\n    },\n    {\n        title: \"Pen Attributes\",\n        examples: [\n            {\n                title: \"Pen Color\",\n                description: \"Changes the pen color. Accepts color names or hex values.\",\n                code: 'pen.color = \"red\"\\nfw(40)'\n            },\n            {\n                title: \"Line Thickness\",\n                description: \"Changes the line thickness (in pixels)\",\n                code: \"pen.thickness = 5\\nfw(40)\"\n            },\n            {\n                title: \"Line Style\",\n                description: \"Changes line style. Options: 'line' (default), 'dash', 'dot'\",\n                code: 'pen.style = \"dash\"\\nfw(40)'\n            },\n            {\n                title: \"Line Opacity\",\n                description: \"Sets line transparency (0.0 to 1.0)\",\n                code: \"pen.opacity = 0.5\\nfw(40)\"\n            }\n        ]\n    },\n    {\n        title: \"Control Structures\",\n        examples: [\n            {\n                title: \"Repeat Loop\",\n                description: \"Repeats a block of code a specified number of times\",\n                code: \"repeat 4:\\n  fw(30)\\n  rt(90)\\nend\"\n            },\n            {\n                title: \"While Loop\",\n                description: \"Repeats while a condition is true\",\n                code: \"x = 0\\nwhile x < 4:\\n  fw(30)\\n  rt(90)\\n  x = x + 1\\nend\"\n            },\n            {\n                title: \"For Loop\",\n                description: \"Iterates over a range of values\",\n                code: \"for i in [1:4]:\\n  fw(30)\\n  rt(90)\\nend\"\n            }\n        ]\n    },\n    {\n        title: \"Comments\",\n        examples: [\n            {\n                title: \"Single Line Comment\",\n                description: \"Add comments to explain your code. Use # to start a comment.\",\n                code: \"# This draws a square\\nfw(40)  # Move forward\\nrt(90)  # Turn right\"\n            }\n        ]\n    }\n];\nfunction createHighlightedCode(code) {\n    const pre = document.createElement('pre');\n    pre.className = 'code-block';\n    code.split('\\n').forEach((line, index) => {\n        const lineDiv = document.createElement('div');\n        lineDiv.className = 'code-line';\n        // Split the line into tokens\n        let tokens = [];\n        let currentPos = 0;\n        // Keywords\n        const keywords = ['pen', 'fw', 'bw', 'rt', 'lt', 'repeat', 'while', 'for', 'in', 'if', 'else', 'end'];\n        const keywordPattern = new RegExp(`\\\\b(${keywords.join('|')})\\\\b`, 'g');\n        // Process each token\n        line.replace(/\\b\\w+\\b|\\d+|[^\\w\\s]|\\s+/g, (match, offset) => {\n            // Add any text before this match\n            if (offset > currentPos) {\n                tokens.push({\n                    text: line.slice(currentPos, offset),\n                    type: 'text'\n                });\n            }\n            // Determine token type\n            let type = 'text';\n            if (keywords.includes(match)) {\n                type = 'keyword';\n            }\n            else if (/^\\d+$/.test(match)) {\n                type = 'number';\n            }\n            else if (/^[\"'].*[\"']$/.test(match)) {\n                type = 'string';\n            }\n            else if (/^\\.[a-zA-Z]+$/.test(match)) {\n                type = 'property';\n            }\n            tokens.push({ text: match, type });\n            currentPos = offset + match.length;\n            return match;\n        });\n        // Add remaining text\n        if (currentPos < line.length) {\n            tokens.push({\n                text: line.slice(currentPos),\n                type: 'text'\n            });\n        }\n        // Create spans for each token\n        tokens.forEach(token => {\n            const span = document.createElement('span');\n            span.textContent = token.text;\n            if (token.type !== 'text') {\n                span.className = token.type;\n            }\n            lineDiv.appendChild(span);\n        });\n        pre.appendChild(lineDiv);\n    });\n    return pre;\n}\nfunction createDocs() {\n    const container = document.getElementById('docs-container');\n    container.innerHTML = '';\n    documentation.forEach(section => {\n        const sectionEl = document.createElement('div');\n        sectionEl.className = 'section';\n        const titleEl = document.createElement('h2');\n        titleEl.textContent = section.title;\n        sectionEl.appendChild(titleEl);\n        section.examples.forEach(example => {\n            const row = document.createElement('div');\n            row.className = 'doc-row';\n            // Description column\n            const descCol = document.createElement('div');\n            descCol.className = 'description';\n            const exTitle = document.createElement('h3');\n            exTitle.textContent = example.title;\n            const exDesc = document.createElement('p');\n            exDesc.textContent = example.description;\n            descCol.appendChild(exTitle);\n            descCol.appendChild(exDesc);\n            // Code and demo column\n            const demoCol = document.createElement('div');\n            demoCol.className = 'code-demo';\n            // Create highlighted code block\n            const codeBlock = createHighlightedCode(example.code);\n            const canvas = document.createElement('div');\n            canvas.className = 'canvas-demo';\n            // Create renderer and execute code\n            const renderer = new renderer_1.TurtleRenderer(canvas, 150);\n            const commands = (0, core_1.runLogo)(example.code);\n            renderer.executeCommands(commands);\n            demoCol.appendChild(codeBlock);\n            demoCol.appendChild(canvas);\n            row.appendChild(descCol);\n            row.appendChild(demoCol);\n            sectionEl.appendChild(row);\n        });\n        container.appendChild(sectionEl);\n    });\n}\n// Update the styles\nconst codeStyles = `\n    .code-block {\n        font-family: 'JetBrains Mono', monospace;\n        font-size: 16px;\n        padding: 15px;\n        background: #f8f9fa;\n        border-radius: 4px;\n        width: 300px;\n        margin: 0;\n    }\n    .code-line {\n        white-space: pre;\n        line-height: 1.5;\n    }\n    .keyword { color: #d73a49; }\n    .number { color: #005cc5; }\n    .string { color: #032f62; }\n    .property { color: #e36209; }\n    .comment { color: #6a737d; font-style: italic; }\n`;\nconst styleSheet = document.createElement('style');\nstyleSheet.textContent = codeStyles;\ndocument.head.appendChild(styleSheet);\ndocument.addEventListener('DOMContentLoaded', createDocs);\n\n\n//# sourceURL=webpack://logobot-v3/./src/docs.ts?");

/***/ }),

/***/ "./src/renderer.ts":
/*!*************************!*\
  !*** ./src/renderer.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TurtleRenderer = void 0;\n// Centralized default pen options\nconst defaultPenOptions = {\n    color: '#00cecb',\n    thickness: 2,\n    style: 'line',\n    cap: 'round',\n    opacity: 1,\n    dashArray: ''\n};\nclass TurtleRenderer {\n    constructor(container, defaultSize = 1000, pointerOptions, penOptions) {\n        this.container = container;\n        this.defaultSize = defaultSize;\n        this.x = 0;\n        this.y = 0;\n        this.angle = -90;\n        this.penDown = true;\n        this.statusBar = null;\n        // Get container size or use default\n        const rect = container.getBoundingClientRect();\n        this.width = rect.width || defaultSize;\n        this.height = rect.height || defaultSize;\n        // Initialize pen and pointer options\n        this.pointerOptions = {\n            size: 10,\n            color: '#ff69b4',\n            anchorPoint: [0, -0.5],\n            ...pointerOptions\n        };\n        this.penOptions = { ...defaultPenOptions, ...penOptions };\n        // Check if an SVG already exists\n        let existingSvg = container.querySelector('svg');\n        if (existingSvg) {\n            this.svg = existingSvg;\n            this.linesGroup = this.svg.querySelector('g:first-child');\n            this.turtleGroup = this.svg.querySelector('g:last-child');\n        }\n        else {\n            // Create new SVG and groups if none exist\n            this.svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            this.svg.setAttribute('width', '100%');\n            this.svg.setAttribute('height', '100%');\n            this.svg.setAttribute('viewBox', `0 0 ${this.width} ${this.height}`);\n            this.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n            this.linesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            this.turtleGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n            this.svg.appendChild(this.linesGroup);\n            this.svg.appendChild(this.turtleGroup);\n            container.appendChild(this.svg);\n        }\n        // Check if status bar exists\n        let existingStatus = container.querySelector('.turtle-status');\n        if (!existingStatus && defaultSize === 1000) {\n            this.statusBar = document.createElement('div');\n            this.statusBar.className = 'turtle-status';\n            container.appendChild(this.statusBar);\n        }\n        else if (existingStatus) {\n            this.statusBar = existingStatus;\n        }\n        this.reset();\n    }\n    createTurtlePointer() {\n        const { size, color, anchorPoint } = this.pointerOptions;\n        const ax = anchorPoint[0] * size;\n        const ay = anchorPoint[1] * size;\n        const points = [\n            [-size / 2 - ax, -size / 2 - ay],\n            [size / 2 - ax, -size / 2 - ay],\n            [0 - ax, size - ay]\n        ].map(([x, y]) => `${x},${y}`).join(' ');\n        const pointer = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');\n        pointer.setAttribute('points', points);\n        pointer.setAttribute('fill', color);\n        pointer.setAttribute('transform', 'rotate(-90)');\n        this.turtleGroup.appendChild(pointer);\n        this.updateTurtleTransform();\n    }\n    updateTurtleTransform() {\n        this.turtleGroup.setAttribute('transform', `translate(${this.x} ${this.y}) rotate(${this.angle})`);\n        if (this.statusBar) {\n            const centerX = this.width / 2;\n            const centerY = this.height / 2;\n            const dx = Math.round(this.x - centerX);\n            const dy = Math.round(centerY - this.y);\n            let angle = (this.angle + 90) % 360;\n            if (angle < 0)\n                angle += 360;\n            this.statusBar.textContent =\n                `Angle: ${angle.toFixed(1)}Â° | X: ${dx} | Y: ${dy}`;\n        }\n    }\n    move(distance) {\n        const radians = (this.angle * Math.PI) / 180;\n        const newX = this.x + distance * Math.cos(radians);\n        const newY = this.y + distance * Math.sin(radians);\n        if (this.penDown) {\n            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n            line.setAttribute('x1', this.x.toString());\n            line.setAttribute('y1', this.y.toString());\n            line.setAttribute('x2', newX.toString());\n            line.setAttribute('y2', newY.toString());\n            line.setAttribute('stroke', this.penOptions.color);\n            line.setAttribute('stroke-width', this.penOptions.thickness.toString());\n            line.setAttribute('stroke-linecap', this.penOptions.cap);\n            line.setAttribute('opacity', this.penOptions.opacity.toString());\n            if (this.penOptions.dashArray) {\n                line.setAttribute('stroke-dasharray', this.penOptions.dashArray);\n            }\n            this.linesGroup.appendChild(line);\n        }\n        this.x = newX;\n        this.y = newY;\n        this.updateTurtleTransform();\n    }\n    turn(degrees) {\n        this.angle = (this.angle + degrees) % 360;\n        if (this.angle < 0) {\n            this.angle += 360;\n        }\n        this.updateTurtleTransform();\n    }\n    executeCommands(commands) {\n        this.clear();\n        for (const cmd of commands) {\n            switch (cmd.type) {\n                case 'move':\n                    this.move(cmd.value);\n                    break;\n                case 'turn':\n                    this.turn(cmd.value);\n                    break;\n                case 'setPenColor':\n                    this.penOptions.color = cmd.value;\n                    break;\n                case 'setPenThickness':\n                    this.penOptions.thickness = cmd.value;\n                    break;\n                case 'setPenOpacity':\n                    this.penOptions.opacity = cmd.value;\n                    break;\n                case 'setPenStyle':\n                    this.penOptions.style = cmd.value;\n                    // Apply dash array based on style\n                    if (cmd.value === 'dash') {\n                        this.penOptions.dashArray = '10,5';\n                    }\n                    else if (cmd.value === 'dot') {\n                        this.penOptions.dashArray = '2,2';\n                    }\n                    else {\n                        this.penOptions.dashArray = '';\n                    }\n                    break;\n                case 'setPenCap':\n                    this.penOptions.cap = cmd.value;\n                    break;\n                case 'penUp':\n                    this.penDown = false;\n                    break;\n                case 'penDown':\n                    this.penDown = true;\n                    break;\n            }\n        }\n    }\n    clear() {\n        // Remove any existing SVGs except the current one\n        const svgs = this.container.querySelectorAll('svg');\n        svgs.forEach(svg => {\n            if (svg !== this.svg) {\n                svg.remove();\n            }\n        });\n        // Clear the lines\n        while (this.linesGroup.firstChild) {\n            this.linesGroup.removeChild(this.linesGroup.firstChild);\n        }\n        this.reset();\n    }\n    reset() {\n        this.x = this.width / 2;\n        this.y = this.height / 2;\n        this.angle = -90;\n        this.penDown = true;\n        // Reset pen options to default\n        this.penOptions = { ...defaultPenOptions };\n        while (this.turtleGroup.firstChild) {\n            this.turtleGroup.removeChild(this.turtleGroup.firstChild);\n        }\n        this.createTurtlePointer();\n    }\n    // Method to update pointer options\n    updatePointerOptions(options) {\n        this.pointerOptions = {\n            ...this.pointerOptions,\n            ...options\n        };\n        // Recreate pointer with new options\n        while (this.turtleGroup.firstChild) {\n            this.turtleGroup.removeChild(this.turtleGroup.firstChild);\n        }\n        this.createTurtlePointer();\n    }\n}\nexports.TurtleRenderer = TurtleRenderer;\n\n\n//# sourceURL=webpack://logobot-v3/./src/renderer.ts?");

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__("./src/docs.ts"));
/******/ }
]);